{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}

module BridgeSupport where

import qualified Data.ByteString.Char8 as BSC
import           Data.BridgeSupport (BridgeSupport)
import qualified Data.BridgeSupport as Bridge

import           Headers
import           SrcPos
import           SyntaxTree

-- data BridgeSupport = BridgeSupport
--     { dependsOn         :: [FilePath]
--     , structs           :: [Struct]
--     , opaqueTypes       :: [TypeInfo]
--     , cfTypes           :: [CFType]
--     , constants         :: [Constant]
--     , stringConstants   :: [StringConstant]
--     , enumTypes         :: [EnumType]
--     , functions         :: [Function]
--     , informalProtocols :: [ClassInterface]
--     , classes           :: [ClassInterface]
--     } deriving (Eq, Show)

bridgeSupportToHeader :: String -> BridgeSupport -> HeaderInfo
bridgeSupportToHeader framework bridgeSupport = HeaderInfo moduleName imports decls
  where
    moduleName = BSC.pack $ haskellizeModuleName framework
    imports = [] -- TODO: dependsOn?
    decls = bridgeSupportToDecls bridgeSupport

bridgeSupportToDecls :: BridgeSupport -> ParsedHeader
bridgeSupportToDecls bridgeSupport = map (AutoGeneratedPos,) $ classes <> structs <> opaqueTypes <> cfTypes <> constants <> stringConstants <> enumTypes <> functions <> informalProtocols
  where
    classes = [] -- map convertClasses $ Bridge.classes bridgeSupport
    -- TODO
    structs = []
    opaqueTypes = []
    cfTypes = []
    constants = []
    stringConstants = []
    enumTypes = []
    functions = []
    informalProtocols = []

    -- convertClasses ClassInterface{..} = SelectorList (Interface clsName mbSuper protocols) contents

